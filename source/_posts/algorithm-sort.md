---
title: 排序算法
categories: [算法]
tags: []
toc: true
date: 2020/7/16
---

# 如何分析排序算法

> 此处的思路属于通用算法分析，需要非常熟悉

## 执行效率 时间复杂度

1. 最好情况，最坏情况，平均情况 时间复杂度
   平均时间复杂度怎么分析？
   - 加权平均期望时间复杂度（较为复杂）
   - 通过有序度 和 逆序度来进行分析(具体见冒泡排序的平均时间复杂度分析)
2. 时间复杂度的系数，常数，低阶

- 低阶是什么？
  当前数据的规模有多大？10 ，1000，100000 对不同的算法是有影响的

3. 比较次数和交换次数

## 内存消耗 空间复杂度

是否为原地排序算法

## 稳定性

稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变

# 具体分析

## 冒泡排序

- 时间复杂度

  - 最好情况
  - 最坏情况
  - 平均情况
    “有序度”和“逆序度”的方式进行分析:

    ```js
    有序元素对：a[i] <= a[j] && i < j

    2, 4, 3, 1, 5, 6 有序度为11
    (2,4) (2,3) (2, 5) (2, 6) (4, 5) (4, 6) (3, 5) (3, 6) (1, 5) (1, 6) (5, 6)

    满有序度：完全递增排序的数组 1,2,3,4,5,6 有序度为 n * (n-1) / 2
    逆序度 = 满有序度 - 有序度
          = n * (n-1) / 2 - 初始有序度
    对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？
    最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。
    最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。
    我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况
    ```

- 是否为原地排序 ：是
- 是否稳定 ：是
  当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
